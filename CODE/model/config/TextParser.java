package model.config;

import model.Player;
import model.Position;

import java.io.File;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;

import java.util.ArrayList;
import java.util.Scanner;
import java.util.regex.Pattern;
import java.util.InputMismatchException;

/**
 * A parser of a Tron configuration for text files.
 * 
 * @author Daniel Hessellund Egeberg
 * @author Søren Dahlgaard
 * @author Martin Nicklas Jørgensen
 * 
 * @version 1
 */
public class TextParser implements IParser
{
    private File file;

    /**
     * Constructs a new TextParser to work on the specified file.
     * 
     * @throws  FileNotFoundException   if the file does not exist
     * @param   file    The file to parse.
     */
    public TextParser(File file) throws FileNotFoundException
    {
        this.file = file;

        if (!file.isFile())
            throw new FileNotFoundException("The specified file does not exist.");
    }

    /**
     * Constructs a new TextParser to work on the file with the specified path
     * 
     * @throws  FileNotFoundException    If the specified path is not a file
     * @param   fileName    The path to the file.
     */
    public TextParser(String fileName) throws FileNotFoundException
    {
        this(new File(fileName));
    }

    /**
     * Extract data from the file the class is storing, and converts it into a Configuration instance for the game to use.
     * NOTE:
     * This scanner uses a method we learned from the weekly assignment no. 5 (phonemore), more specifically, the parser class.
     * Nothing is actually copied from the class, but that is the reason for any resemblance.
     * @return  A Configuration object with all the data.
     * @throws  ParserException An exception message generated by the parser. Only the message is filled by the parser, but it's pretty precise.
     */
    public Configuration getConfiguration() throws ParserException
    {
        Reader reader;
        Scanner s;
        String error = "";
        
        // to minimize the number of nested try/catch'-s i only used one and then make dynamic error messages for the weird situations.
        try {

            reader = new BufferedReader(new FileReader(this.file));
            s = new Scanner(reader);

            // variable not strictly needed by code, but gives a clue to where IN THE TRON file the problem is.
            int lineRead = 1;

            // data needed by the Configuration class.
            int width = 0;
            int height = 0;
            int scaleFactor = 0;
            ArrayList<LineSegment> segments = new ArrayList<LineSegment>();
            ArrayList<Position> players = new ArrayList<Position>();

            while (s.hasNext()) {

                if(s.hasNextInt()) {
                    width = s.nextInt();
                    height = s.nextInt();
                    scaleFactor = s.nextInt();
                }
                else {
                    error = "File had invalid top line";
                }

                if(s.hasNext()){
                    lineRead++;
                    s.nextLine();

                    String typeName = s.next();

                    if (typeName.equals("line:")) {
                        int p1x = s.nextInt();
                        int p1y = s.nextInt();
                        int p2x = s.nextInt();
                        int p2y = s.nextInt();

                        segments.add(new LineSegment(p1x, p1y, p2x, p2y));
                    }
                    else if(typeName.equals("player:")) {
                        int playerX = s.nextInt();
                        int playerY = s.nextInt();

                        players.add(new Position(playerX, playerY));
                    }
                    else {
                        error = "Invalid TRON-data found in file at line " + lineRead;
                    }
                }
            }
            reader.close();
            return new Configuration(width, height, scaleFactor, segments, players);
        }
        catch (Exception ex) {
            throw new ParserException(error);
        }
    }

}
